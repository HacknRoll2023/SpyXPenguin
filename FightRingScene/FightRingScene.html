<!DOCTYPE html>
<html>
  <head>
    <title>Fighting off evil Seals!</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />

    <!-- <link rel="icon" href="../images/icon.png"> -->

    <!-- Handtracking scripts -->
    <meta charset="utf-8" />
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>

    <style>
      .handtrack-container {
        position: absolute;
        z-index: 10;
        float: left;
      }

      /* Overlays */
      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 100;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #overlay-win {
        display: none;
        justify-content: center;
        align-items: center;
      }

      #overlay-lose {
        display: none;
        justify-content: center;
        align-items: center;
      }

      #overlay-start {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .overlay-content {
        background-color: #fff;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
      }

      .overlay-content h1 {
        margin-top: 0;
      }

      .overlay-content p {
        margin-bottom: 0;
      }

      .overlay-content button {
        padding: 10px 20px;
        font-size: 20px;
        border: none;
        border-radius: 5px;
        background-color: #333;
        color: #fff;
        cursor: pointer;
      }

      .overlay-content button:hover {
        background-color: #555;
      }
    </style>
  </head>

  <body>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "../jsm/"
        }
      }
    </script>

    <!-- Handtracking -->
    <div class="handtrack-container">
      <canvas class="output_canvas" width="320px" height="185px"></canvas>

      <div class="container">
        <div class="digit-positions-left">
          <div class="digit-position">
            <p class="digit-positions__label">Right Hand</p>
            <div class="digit-position__value"></div>
          </div>
        </div>

        <div class="digit-positions-right">
          <div class="digit-position">
            <p class="digit-positions__label">Left Hand</p>
            <div class="digit-position__value"></div>
          </div>
        </div>
      </div>

      <!-- Game debug -->
      <div id="output-debug"></div>
      <div id="penguinLives"></div>

      <video class="input_video"></video>
    </div>

    <div id="overlay-start" class="overlay">
      <div class="overlay-content">
        <h1>Fight Ring screen</h1>
        <p>
          Use your hands to spin around and hit the seals. You have 3 lives.
        </p>
        <p>
          <button
            id="startButton"
            onclick="gameState = 'playing'; document.getElementById('overlay-start').style.display = 'none';"
          >
            Start
          </button>
        </p>
      </div>
    </div>

    <div id="overlay-lose" class="overlay">
      <div class="overlay-content">
        <h1>Game Over</h1>
        <p>
          <button id="startButton" onclick="location.reload();">
            Play Again
          </button>
        </p>
      </div>
    </div>

    <div id="overlay-win" class="overlay">
      <div class="overlay-content">
        <h1>You Win!</h1>
        <p>
          <button id="startButton" onclick="location.reload();">
            Play Again
          </button>
        </p>
      </div>
    </div>

    <script type="module">
      // Game variables ------------------------------------------------------------
      var gameState = "playing";

      var penguinLives = 3;

      // Scene variables
      var penguinPosition = {
        x: 0,
        z: 0,
      };
      var penguinRotation = 0;

      var isShooting = false;

      var numSnowballs = 0;
      var maxSnowballs = 5;
      var snowballPositions = [];
      var snowballSpeed = 0.4;
      var snowballRadius = 0.2;

      var maxSeals = 20;
      var numSeals = 20;
      var sealPositions = [];
      var sealSpeed = 0.1;

      var fightRingRadius = 20; // spawn area for seals

      var penguinHitRadius = 0.5;
      var sealHitRadius = 0.5;

      // Controls variables (based on Middle Finger Pip [number 10])
      var rightHandPosition = {
        mcp: {
          x: 0,
          y: 0,
        },
        pip: {
          x: 0,
          y: 0,
        },
      };

      var rightHandOpen = false;
      var firstRightHandOpen = false;

      // Handtracking ------------------------------------------------------------
      const videoElement = document.getElementsByClassName("input_video")[0];
      const canvasElement = document.getElementsByClassName("output_canvas")[0];
      const canvasCtx = canvasElement.getContext("2d");

      const digitPositions = document.getElementsByClassName(
        "digit-position__value"
      );

      // hide the video element, and just show the canvas
      videoElement.style.display = "none";

      // Function to handle handtracking
      function onResults(results) {
        // Mirror the video feed and draw the results on the canvas
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.translate(canvasElement.width, 0);
        canvasCtx.scale(-1, 1);
        canvasCtx.drawImage(
          results.image,
          0,
          0,
          canvasElement.width,
          canvasElement.height
        );
        if (results.multiHandLandmarks) {
          for (const landmarks of results.multiHandLandmarks) {
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
              color: "#00FF00",
              lineWidth: 5,
            });
            drawLandmarks(canvasCtx, landmarks, {
              color: "#FF0000",
              lineWidth: 2,
            });
          }
        }

        canvasCtx.restore();

        // wrist - 0
        // thumb tip - 4
        // index tip - 8
        // middle tip - 12
        // ring tip - 16
        // pinky tip - 20

        //   display the coordinates of the tips of the fingers for each hand
        if (results.multiHandLandmarks) {
          for (let i = 0; i < results.multiHandedness.length; i++) {
            const classification = results.multiHandedness[i];
            const isRightHand = !(classification.label === "Right"); // Mirrored

            if (isRightHand) {
              // Get right hand position

              // Right middle mcp (main tracking)
              rightHandPosition.mcp.x = results.multiHandLandmarks[i][9].x;
              rightHandPosition.mcp.y = results.multiHandLandmarks[i][9].y;

              // Right middle dip
              rightHandPosition.pip.x = results.multiHandLandmarks[i][11].x;
              rightHandPosition.pip.y = results.multiHandLandmarks[i][11].y;

              // Check if the right hand is open (middle finger pip is higher than mcp)
              if (rightHandPosition.pip.y < rightHandPosition.mcp.y) {
                rightHandOpen = true;
              } else {
                rightHandOpen = false;
              }
            }
            // display the coordinates of the tips of the fingers for each hand
            const digitPosition = isRightHand
              ? digitPositions[0]
              : digitPositions[1];

            digitPosition.innerText = `
                    Thumb: [${results.multiHandLandmarks[i][4].x.toFixed(
                      2
                    )}, ${results.multiHandLandmarks[i][4].y.toFixed(2)}]
                    Index: [${results.multiHandLandmarks[i][8].x.toFixed(
                      2
                    )}, ${results.multiHandLandmarks[i][8].y.toFixed(2)}]
                    Middle: [${results.multiHandLandmarks[i][12].x.toFixed(
                      2
                    )}, ${results.multiHandLandmarks[i][12].y.toFixed(2)}]
                    Ring: [${results.multiHandLandmarks[i][16].x.toFixed(
                      2
                    )}, ${results.multiHandLandmarks[i][16].y.toFixed(2)}]
                    Pinky: [${results.multiHandLandmarks[i][20].x.toFixed(
                      2
                    )}, ${results.multiHandLandmarks[i][20].y.toFixed(2)}]
                `;
          }
        }

        updateGame();
      }

      // Model set up configuration
      const hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        },
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });
      hands.onResults(onResults);

      const handtrackCamera = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({ image: videoElement });
        },
        width: 1280,
        height: 720,
      });

      // Three.js ------------------------------------------------------------
      import * as THREE from "three";

      // import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
      import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";

      // Scene
      let threeCamera, scene, renderer;
      var threeControls;

      var sceneLoaded = false;

      // Models
      var penguin, alertModel, directionIndicator, fortress;
      var snowballs = [];
      var seals = [];

      function initThree() {
        const container = document.createElement("div");
        document.body.appendChild(container);

        threeCamera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.25,
          20
        );
        threeCamera.position.set(0, 0.2, 0);
        // rotate camera to face the penguin
        threeCamera.lookAt(2, 2, 2);

        scene = new THREE.Scene();
        const clock = new THREE.Clock();

        // Load the background
        new RGBELoader()
          .setPath("./../textures/equirectangular/")
          .load("kloppenheim_06_puresky_2k.hdr", function (texture) {
            texture.mapping = THREE.EquirectangularReflectionMapping;

            scene.background = texture;
            scene.environment = texture;

            // // load in red, green and blue cubes for orientation -----------------------------
            const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // green
            const cube1 = new THREE.Mesh(geometry, material);
            cube1.position.set(0, 0.2, 0);
            scene.add(cube1);

            const geometry2 = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const material2 = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // red
            const cube2 = new THREE.Mesh(geometry2, material2);
            cube2.position.set(0.2, 0, 0);
            scene.add(cube2);

            const geometry3 = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const material3 = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // blue
            const cube3 = new THREE.Mesh(geometry3, material3);
            cube3.position.set(0, 0, 0.2);
            scene.add(cube3);

            render();

            // load in models ---------------------------------------------------------------
            // model set up
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath("../jsm/libs/draco/");

            const loader = new GLTFLoader().setPath("../models/");
            loader.setDRACOLoader(dracoLoader);

            // Penguin model
            const glbPath = "Penguin.gltf";
            loader.load(glbPath, function (gltf) {
              console.log(gltf);
              penguin = gltf.scene;
              penguin.scale.set(0.06, 0.06, 0.06);
              penguin.position.set(0, 0.01, 0);
              penguin.rotation.set(0, (-10 / 180) * Math.PI, 0);
              scene.add(penguin);
            });

            // Add fortress model for target destination
            const glbPath4 = "ArenaIced.gltf";
            loader.load(glbPath4, function (gltf) {
              console.log(gltf);
              fortress = gltf.scene;
              fortress.scale.set(0.2, 0.2, 0.2);
              fortress.position.set(0, -0.82, 0);
              fortress.rotation.set(0, (-10 - 90 / 180) * Math.PI, 0);
              scene.add(fortress);
            });

            // Snowball model for target destination
            const glbPath3 = "Snowball.gltf";
            loader.load(glbPath3, function (gltf) {
              var snowballProjectile = gltf.scene;
              snowballProjectile.scale.set(0.1, 0.1, 0.1);

              // Add all snowballs to the scene
              for (var i = 0; i < maxSnowballs; i++) {
                let snowballProjectile2 = gltf.scene.clone();
                snowballProjectile2.position.set(0, -0.2, 0);
                scene.add(snowballProjectile2);
                snowballs.push(snowballProjectile2);
              }
            });

            // Seals
            const glbPath5 = "SealAngry.gltf";
            loader.load(glbPath5, function (gltf) {
              var sealEnemy = gltf.scene;
              sealEnemy.scale.set(0.1, 0.1, 0.1);

              // Add all sealEnemy to the scene
              for (var i = 0; i < numSeals; i++) {
                let sealEnemy = gltf.scene.clone();
                sealEnemy.position.set(0, -0.4, 0);
                scene.add(sealEnemy);
                seals.push(sealEnemy);
              }
            });

            var groundTexture = new THREE.TextureLoader().load(
              "./../textures/textureImages/snowTexture3.jpg"
            );
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(10000, 10000);
            groundTexture.anisotropy = 64;
            groundTexture.encoding = THREE.sRGBEncoding;

            var groundMaterial = new THREE.MeshStandardMaterial({
              map: groundTexture,
            });

            var mesh = new THREE.Mesh(
              new THREE.PlaneBufferGeometry(10000, 10000),
              groundMaterial
            );
            mesh.position.y = 0;
            mesh.rotation.x = -Math.PI / 2;
            mesh.receiveShadow = true;
            scene.add(mesh);
          });

        // renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        // // Orbit controls
        // threeControls = new OrbitControls(threeCamera, renderer.domElement);
        // threeControls.addEventListener("change", render); // use if there is no animation loop
        // threeControls.minDistance = 1;
        // threeControls.maxDistance = 5;
        // threeControls.target.set(0, 0.25, 0);
        // threeControls.update();

        window.addEventListener("resize", onWindowResize);

        sceneLoaded = true;
      }

      function onWindowResize() {
        threeCamera.aspect = window.innerWidth / window.innerHeight;
        threeCamera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

        render();
      }

      function render() {
        renderer.render(scene, threeCamera);
      }

      // Game logic ------------------------------------------------------------
      function updateGame() {
        if (!sceneLoaded) {
          return;
        }

        if (rightHandOpen) {
          if (!firstRightHandOpen) {
            firstRightHandOpen = true;
            isShooting = true;
          }
        } else {
          firstRightHandOpen = false;
          isShooting = false;
        }

        // Update the camera rotation

        // Update snowball positions

        // Update seal positions

        // Check for collisions between penguin and seals

        // Check for collisions between snowballs and seals

        // CAMERA CONTROLS -------------------------------------------------------
        // Update the camera to look at

        // Render the scene
        render();

        // // Display rotation and shooting --------------------------------
        var outputHTML = "";
        // gesture variables
        outputHTML += "rightHandOpen: " + rightHandOpen + "<br>";
        outputHTML += "firstRightHandOpen: " + firstRightHandOpen + "<br>";

        // hand position variables
        outputHTML += "rightHandPosition: " + rightHandPosition + "<br>";
        outputHTML += "rightHandOpen: " + rightHandOpen + "<br>";

        // game variables
        outputHTML += "rotation: " + penguinRotation + "<br>";
        outputHTML += "shooting: " + isShooting + "<br>";

        // Display the output
        document.getElementById("output-debug").innerHTML = outputHTML;

        // Display penguinLives ---------------------------------------------------
        document.getElementById("penguinLives").innerHTML =
          "lives: " + penguinLives;
      }

      // Initialize ------------------------------------------------------------
      initThree();
      render();

      handtrackCamera.start();
    </script>
  </body>
</html>
